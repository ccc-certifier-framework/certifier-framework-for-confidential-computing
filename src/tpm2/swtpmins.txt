swtpm_setup --tpm2 --tpmstate ${XDG_CONFIG_HOME}/mytpm1     --create-ek-cert --create-platform-cert --lock-nvram
echo $XDG_CONFIG_HOME
/home/jlm/.config
export TPM2TOOLS_TCTI="swtpm:port=2321"
swtpm socket --tpmstate dir=<swtpm_path> --tpm2 --server type=tcp,port=2321 --ctrl type=tcp,port=2322 --flags not-need-init,startup-clear

mkdir -p /tmp/my_swtpm_dir
swtpm_setup --tpm2 --tpmstate /tmp/my_swtpm_dir/ --create-ek-cert --create-platform-cert --lock-nvram
export TPM2TOOLS_TCTI="swtpm:path=/tmp/my_swtpm_dir/swtpm-sock"
tpm2_pcrread sha256
It can interact via a character device path (e.g., /dev/tpm0) 


PCR commands:
TPM2_PCR_Extend, TPM2_PCR_Event, TPM2_Read, TPM2_Reset, TPRM2_Allocate, TPM2_SetAuthorizationPolicy, TPM2_SetAuthorizationValue.

Seal
    1. Construct policy using tpm2_createpolicy, TPM2_policypcr
    2. TPM2_GetRandom to generate key
    3. TPM2_Create to specify policy and key

Unseal
    1. Start Session Auth
    2. TPM2_Load
    3. PolicyPCR
    4. TPM2_Unseal (with blob from Create)
    5. Close session: tpm2_flushcontext

Quote
    1. Policy
    2. Use TPM_GENERATED
    3. Specify qualified name
    4. Specify extra data
    5. FW
    6. Clock
    7. PCR numbers
    8. Digest of PCRs
    9. TPM2_Quote
    10. You have to reload these


in /usr/bin

tpm2_activatecredential
tpm2_certify
tpm2_certifycreation
tpm2_certifyX509certutil
tpm2_changeauth
tpm2_changeeps
tpm2_changepps
tpm2_checkquote
tpm2_clear
tpm2_clearcontrol
tpm2_clockrateadjust
tpm2_commit
tpm2_create
tpm2_createak
tpm2_createek
tpm2_createpolicy
tpm2_createprimary
tpm2_dictionarylockout
tpm2_duplicate
tpm2_ecdhkeygen
tpm2_ecdhzgen
tpm2_ecephemeral
tpm2_encodeobject
tpm2_encryptdecrypt
tpm2_eventlog
tpm2_evictcontrol
tpm2_flushcontext
tpm2_getcap
tpm2_getcommandauditdigest
tpm2_geteccparameters
tpm2_getekcertificate
tpm2_getpolicydigest
tpm2_getrandom --hex 32
tpm2_getsessionauditdigest
tpm2_gettestresult
tpm2_gettime
tpm2_hash
tpm2_hierarchycontrol
tpm2_hmac
tpm2_import
tpm2_incrementalselftest
tpm2_load
tpm2_loadexternal
tpm2_makecredential
tpm2_nvcertify
tpm2_nvdefine
tpm2_nvextend
tpm2_nvincrement
tpm2_nvread
tpm2_nvreadlock
tpm2_nvreadpublic
tpm2_nvsetbits
tpm2_nvundefine
tpm2_nvwrite
tpm2_nvwritelock
tpm2_pcrallocate
tpm2_pcrevent
tpm2_pcrextend
tpm2_pcrread
tpm2_pcrreset
tpm2_policyauthorize
tpm2_policyauthorizenv
tpm2_policyauthvalue
tpm2_policycommandcode
tpm2_policycountertimer
tpm2_policycphash
tpm2_policyduplicationselect
tpm2_policylocality
tpm2_policynamehash
tpm2_policynv
tpm2_policynvwritten
tpm2_policyor
tpm2_policypassword
tpm2_policypcr
tpm2_policyrestart
tpm2_policysecret
tpm2_policysigned
tpm2_policytemplate
tpm2_policyticket
tpm2_print
tpm2_quote
tpm2_rc_decode
tpm2_readclock
tpm2_readpublic
tpm2_rsadecrypt
tpm2_rsaencrypt
tpm2_selftest
tpm2_send
tpm2_sessionconfig
tpm2_setclock
tpm2_setcommandauditstatus
tpm2_setprimarypolicy
tpm2_shutdown
tpm2_sign
tpm2_startauthsession
tpm2_startup
tpm2_stirrandom
tpm2_testparms
tpm2_tr_encode
tpm2_unseal
tpm2_verifysignature
tpm2_zgen2phase

tpm2_getrandom --hex 32
tpm2_readclock
tpm2_pcrread sha256
tpm2_policypcr [ -L | --policy=<value>] [ -f | --pcr=<value>] [ -l | --pcr-list=<value>] [ -S | --session=<value>]
tpm2_createpolicy [ -L | --policy=<value>] [ -g | --policy-algorithm=<value>] [ -l | --pcr-list=<value>] [ -f | --pcr=<value>]
    [ --policy-pcr] [ --policy-session]
tpm2_create [ -P | --parent-auth=<value>] [ -p | --key-auth=<value>] [ -g | --hash-algorithm=<value>] [ -G | --key-algorithm=<value>]
    [ -a | --attributes=<value>] [ -i | --sealing-input=<value>] [ -L | --policy=<value>] [ -u | --public=<value>]
    [ -r | --private=<value>] [ -C | --parent-context=<value>] [ -c | --key-context=<value>] [ --creation-data=<value>]
    [ --template-data=<value>] [ -t | --creation-ticket=<value>] [ -d | --creation-hash=<value>] [ -q | --outside-info=<value>]
    [ -l | --pcr-list=<value>] [ --cphash=<value>] [ --rphash=<value>] [ -S | --session=<value>]
    [ -f | --format=<value>] [ -o | --output=<value>]
tpm2_startauthsession    [ --policy-session] [ --audit-session] [ --bind-context=<value>] [ --bind-auth=<value>]
    [ --tpmkey-context=<value>] [ --hmac-session] [ -g | --hash-algorithm=<value>] [ -G | --key-algorithm=<value>]
    [ -S | --session=<value>] [ -c | --key-context=<value>] [ -n | --name=<value>]
tpm2_unseal [ -p | --auth=<value>] [ -o | --output=<value>] [ -c | --object-context=<value>] [ --cphash=<value>]
    [ --rphash=<value>] [ -S | --session=<value>]
tmp2_quote [ -c | --key-context=<value>] [ -p | --auth=<value>] [ -l | --pcr-list=<value>] [ -q | --qualification=<value>]
    [ -s | --signature=<value>] [ -m | --message=<value>] [ -o | --pcr=<value>] [ -F | --pcrs_format=<value>]
    [ -f | --format=<value>] [ -g | --hash-algorithm=<value>] [ --cphash=<value>] [ --scheme=<value>]


tpm2_load [ -P | --auth=<value>] [ -u | --public=<value>] [ -r | --private=<value>] [ -n | --name=<value>]
    [ -c | --key-context=<value>] [ -C | --parent-context=<value>] [ --cphash=<value>]


Tpm2_StartAuthSession(LocalTpm& tpm, TPM_RH tpm_obj, TPM_RH bind_obj, TPM2B_NONCE& initial_nonce, TPM2B_ENCRYPTED_SECRET& salt, TPM_SE session_type, TPMT_SYM_DEF& symmetric, TPMI_ALG_HASH hash_alg, TPM_HANDLE* session_handle, TPM2B_NONCE* nonce_obj);
bool Tpm2_PolicyPcr(LocalTpm& tpm, TPM_HANDLE session_handle, TPM2B_DIGEST& expected_digest, TPML_PCR_SELECTION& pcr);



TPM2 Qualified Names are unique identifiers for TPM objects (keys, NV indices)
that include the hash of the parent object’s name in the hierarchy (e.g.,
Endorsement Hierarchy). This structure binds an object to its parent, ensuring
it belongs to a specific TPM, crucial for remote attestation and ensuring secure,
trusted key creation.

Definition: A qualified name is the name algorithm hash of the parent’s
qualified name concatenated with the object’s own name.

Purpose: It acts as proof that an object, such as an Attestation Key (AK),
was created under a specific parent object, typically the Endorsement Key (EK).

Hierarchy Binding: The qualified name chain extends from the object up to
the Primary Seed (e.g., Owner, Platform, or Endorsement Hierarchy),
allowing verification of the entire hierarchy.

Usage in Tools: tpm2_createak utilizes the -q option to record this,
verifying the key's ancestry. tpm2_readpublic is used to read this name.

Structure: Unlike a simple name, which is just the hash of the public
area, the qualified name includes the parent's information, providing
a secure, hierarchical, and verifiable identifier for keys. 


GetEndorsementKey.cc
  primary_flags.fixedTPM = 1;
  primary_flags.fixedParent = 1;
  primary_flags.sensitiveDataOrigin = 1;
  primary_flags.userWithAuth = 1;
  primary_flags.decrypt = 1;
  primary_flags.restricted = 1;
  InitSinglePcrSelection(7, hash_alg_id, &pcrSelect);
  if (Tpm2_CreatePrimary(tpm, TPM_RH_ENDORSEMENT, emptyAuth, pcrSelect,
                         TPM_ALG_RSA, hash_alg_id, primary_flags,
                         TPM_ALG_AES, 128, TPM_ALG_CFB, TPM_ALG_NULL,
                         2048, 0x010001, &ekHandle, &pub_out))
  Tpm2_ReadPublic(tpm, ekHandle, &pub_blob_size, pub_blob,
                      &pub_out, &pub_name, &qualified_pub_name)
  Tpm2_FlushContext(tpm, ekHandle);

  string authString("01020304");
  string parentAuth("01020304");
  string emptyAuth;

  TPML_PCR_SELECTION pcrSelect;
  TPMA_OBJECT root_flags;

  TPM2B_CREATION_DATA creation_out;
  TPM2B_DIGEST digest_out;
  TPMT_TK_CREATION creation_ticket;

  TPM_HANDLE root_handle = 0;
  TPM2B_PUBLIC root_pub_out;

  TPM_HANDLE seal_load_handle = 0;
  TPMA_OBJECT seal_create_flags;
  TPM2B_NAME seal_name;
  int seal_size_public = MAX_SIZE_PARAMS;
  byte seal_out_public[MAX_SIZE_PARAMS];
  int seal_size_private = MAX_SIZE_PARAMS;
  byte seal_out_private[MAX_SIZE_PARAMS];

  TPMA_OBJECT quote_create_flags;
  TPM2B_NAME quote_name;
  TPM_HANDLE quote_load_handle = 0;
  int quote_size_public = MAX_SIZE_PARAMS;
  byte quote_out_public[MAX_SIZE_PARAMS];
  int quote_size_private = MAX_SIZE_PARAMS;
  byte quote_out_private[MAX_SIZE_PARAMS];

  TPM_HANDLE nv_handle = 0;
  byte context_save_area[MAX_SIZE_PARAMS];
  uint16_t context_data_size = MAX_SIZE_PARAMS;
  TPM_HANDLE sealed_load_handle = 0;
  TPM_ALG_ID hash_alg_id;
  InitSinglePcrSelection(7, hash_alg_id, &pcrSelect);
  *(uint32_t*)(&root_flags) = 0;
  root_flags.fixedTPM = 1;
  root_flags.fixedParent = 1;
  root_flags.sensitiveDataOrigin = 1;
  root_flags.userWithAuth = 1;
  root_flags.decrypt = 1;
  root_flags.restricted = 1;
  if (Tpm2_CreatePrimary(tpm, TPM_RH_OWNER, authString, pcrSelect,
                         TPM_ALG_RSA, hash_alg_id, root_flags,
                         TPM_ALG_AES, 128, TPM_ALG_CFB, TPM_ALG_NULL,
                         2048, 0x010001, &root_handle, &root_pub_out)) 
 *(uint32_t*)(&seal_create_flags) = 0;
  seal_create_flags.fixedTPM = 1;
  seal_create_flags.fixedParent = 1;
  seal_create_flags.sensitiveDataOrigin = 1;
  seal_create_flags.userWithAuth = 1;
  seal_create_flags.sign = 1;

  if (Tpm2_CreateKey(tpm, root_handle, parentAuth, authString, pcrSelect,
                     TPM_ALG_RSA, hash_alg_id, seal_create_flags, TPM_ALG_NULL,
                     (TPMI_AES_KEY_BITS)0, TPM_ALG_ECB, TPM_ALG_RSASSA,
                     2048, 0x010001, &seal_size_public, seal_out_public,
                     &seal_size_private, seal_out_private,
                     &creation_out, &digest_out, &creation_ticket)) {
  if (Tpm2_Load(tpm, root_handle, parentAuth, seal_size_public,
                seal_out_public, seal_size_private, seal_out_private,
                &seal_load_handle, &seal_name)) {

  *(uint32_t*)(&quote_create_flags) = 0;
  quote_create_flags.fixedTPM = 1;
  quote_create_flags.fixedParent = 1;
  quote_create_flags.sensitiveDataOrigin = 1;
  quote_create_flags.userWithAuth = 1;
  quote_create_flags.sign = 1;
  quote_create_flags.restricted = 1;
  if (Tpm2_CreateKey(tpm, root_handle, parentAuth, authString, pcrSelect,
                     TPM_ALG_RSA, hash_alg_id, quote_create_flags, TPM_ALG_NULL,
                     (TPMI_AES_KEY_BITS)0, TPM_ALG_ECB, TPM_ALG_RSASSA,
                     1024, 0x010001,
                     &quote_size_public, quote_out_public,
                     &quote_size_private, quote_out_private,
                     &creation_out, &digest_out, &creation_ticket)) {
  if (Tpm2_Load(tpm, root_handle, parentAuth, quote_size_public,
                quote_out_public, quote_size_private, quote_out_private,
                &quote_load_handle, &quote_name)) {
  nv_handle = GetNvHandle(FLAGS_slot_primary);
  context_data_size = MAX_SIZE_PARAMS;
  if (!Tpm2_SaveContext(tpm, root_handle, &context_data_size,
                        context_save_area)) {
  Tpm2_UndefineSpace(tpm, TPM_RH_OWNER, nv_handle))
  if (!Tpm2_WriteNv(tpm, nv_handle, authString,
                    (uint16_t)context_data_size, context_save_area)){
  if (!Tpm2_SaveContext(tpm, seal_load_handle, &context_data_size,
                        context_save_area)) {

  if (!Tpm2_WriteNv(tpm, nv_handle, authString,
                    (uint16_t)context_data_size, context_save_area)){
  // Save quote context
  nv_handle = GetNvHandle(FLAGS_slot_quote);
  context_data_size = MAX_SIZE_PARAMS;
  if (!Tpm2_SaveContext(tpm, quote_load_handle, &context_data_size,
                        context_save_area)) {
  if (root_handle != 0) {
    Tpm2_FlushContext(tpm, root_handle);
  }
  if (seal_load_handle != 0) {
    Tpm2_FlushContext(tpm, seal_load_handle);
  }
  if (quote_load_handle != 0) {
    Tpm2_FlushContext(tpm, quote_load_handle);
  }
  if (sealed_load_handle != 0) {
    Tpm2_FlushContext(tpm, sealed_load_handle);
}

void InitSinglePcrSelection(int pcrNum, TPM_ALG_ID hash,
                            TPML_PCR_SELECTION* pcrSelect) {
  if (pcrNum == -1) {
    pcrSelect->count = 0; 
    return;
  }
  pcrSelect->count = 1;
  pcrSelect->pcrSelections[0].hash = hash;
  pcrSelect->pcrSelections[0].sizeofSelect = 3;
  for (int i = 0; i < 3; i++)
    pcrSelect->pcrSelections[0].pcrSelect[i] = 0;
  if (pcrNum != 0)
    setPcrBit(pcrNum, pcrSelect->pcrSelections[0].pcrSelect);
} 

bool Tpm2_SealCombinedTest(LocalTpm& tpm, int pcr_num) {
  string authString("01020304");
  string parentAuth("01020304");
  string emptyAuth;

  TPM_HANDLE parent_handle;
  TPM2B_PUBLIC pub_out;
  TPML_PCR_SELECTION pcrSelect;
  InitSinglePcrSelection(pcr_num, TPM_ALG_SHA1, &pcrSelect);

  TPMA_OBJECT primary_flags;
  *(uint32_t*)(&primary_flags) = 0;
  primary_flags.fixedTPM = 1;
  primary_flags.fixedParent = 1;
  primary_flags.sensitiveDataOrigin = 1;
  primary_flags.userWithAuth = 1;
  primary_flags.decrypt = 1;
  primary_flags.restricted = 1;

  if (Tpm2_CreatePrimary(tpm, TPM_RH_OWNER, authString, pcrSelect, 
                         TPM_ALG_RSA, TPM_ALG_SHA1, primary_flags,
                         TPM_ALG_AES, 128, TPM_ALG_CFB, TPM_ALG_NULL,
                         1024, 0x010001,
                        &parent_handle, &pub_out)) {
    printf("CreatePrimary succeeded\n");
  }
  
  TPM2B_DIGEST secret;
  secret.size = 16;
  for  (int i = 0; i < 16; i++)
    secret.buffer[i] = (byte_t)(i + 1);

  TPM2B_CREATION_DATA creation_out;
  TPMT_TK_CREATION creation_ticket;
  int size_public = MAX_SIZE_PARAMS;
  byte_t out_public[MAX_SIZE_PARAMS];
  int size_private = MAX_SIZE_PARAMS;
  byte_t out_private[MAX_SIZE_PARAMS];

  TPM2B_DIGEST digest_out;
  TPM2B_NONCE initial_nonce;
  TPM2B_ENCRYPTED_SECRET salt;
  TPMT_SYM_DEF symmetric;
  TPM_HANDLE session_handle;
  TPM2B_NONCE nonce_obj;

  initial_nonce.size = 16;
  memset(initial_nonce.buffer, 0, 16);
  salt.size = 0;
  symmetric.algorithm = TPM_ALG_NULL;
  
  // Start auth session
  if (Tpm2_StartAuthSession(tpm, TPM_RH_NULL, TPM_RH_NULL,
                            initial_nonce, salt, TPM_SE_POLICY,
                            symmetric, TPM_ALG_SHA1, &session_handle,
                            &nonce_obj)) {
    printf("Tpm2_StartAuthSession succeeds handle: %08x\n",
           session_handle);
    printf("nonce (%d): ", nonce_obj.size);
    PrintBytes(nonce_obj.size, nonce_obj.buffer);
    printf("\n");
  }

  TPM2B_DIGEST policy_digest;
  // get policy digest
  if(Tpm2_PolicyGetDigest(tpm, session_handle, &policy_digest)) {
    printf("PolicyGetDigest before Pcr succeeded: ");
    PrintBytes(policy_digest.size, policy_digest.buffer); printf("\n");
  }

  if (Tpm2_PolicyPassword(tpm, session_handle)) {
    printf("PolicyPassword succeeded\n");
  }

  TPM2B_DIGEST expected_digest;
  expected_digest.size = 0;
  if (Tpm2_PolicyPcr(tpm, session_handle,
                     expected_digest, pcrSelect)) {
    printf("PolicyPcr succeeded\n");
  }

  if(Tpm2_PolicyGetDigest(tpm, session_handle, &policy_digest)) {
    printf("PolicyGetDigest succeeded: ");
    PrintBytes(policy_digest.size, policy_digest.buffer); printf("\n");
  }

  TPMA_OBJECT create_flags;
  *(uint32_t*)(&create_flags) = 0;
  create_flags.fixedTPM = 1;
  create_flags.fixedParent = 1;

  if (Tpm2_CreateSealed(tpm, parent_handle, policy_digest.size,
                        policy_digest.buffer, parentAuth, secret.size,
                        secret.buffer, pcrSelect, TPM_ALG_SHA1, create_flags,
                        TPM_ALG_NULL, (TPMI_AES_KEY_BITS)0, TPM_ALG_ECB,
                        TPM_ALG_RSASSA, 1024, 0x010001,
                        &size_public, out_public, &size_private, out_private,
                        &creation_out, &digest_out, &creation_ticket)) {
    printf("Create with digest succeeded private size: %d, public size: %d\n",
           size_private, size_public);
  }

  TPM_HANDLE load_handle;
  TPM2B_NAME name;
  if (Tpm2_Load(tpm, parent_handle, parentAuth, size_public, out_public,
               size_private, out_private, &load_handle, &name)) {
    printf("Load succeeded\n");
  }

  int unsealed_size = MAX_SIZE_PARAMS;
  byte_t unsealed[MAX_SIZE_PARAMS];
  TPM2B_DIGEST hmac;
  hmac.size = 0;
  if (!Tpm2_Unseal(tpm, load_handle, parentAuth, session_handle,
                   nonce_obj, 0x01, hmac,
                   &unsealed_size, unsealed)) {
    printf("Unseal failed\n");
    Tpm2_FlushContext(tpm, session_handle);
    Tpm2_FlushContext(tpm, load_handle);
    return false;
  }
  printf("Unseal succeeded, unsealed (%d): ", unsealed_size); 
  PrintBytes(unsealed_size, unsealed);
  printf("\n"); 
  Tpm2_FlushContext(tpm, session_handle);
  Tpm2_FlushContext(tpm, load_handle);
  return true;
}

bool Tpm2_QuoteCombinedTest(LocalTpm& tpm, int pcr_num) {
  string authString("01020304");
  string parentAuth("01020304");
  string emptyAuth;

  TPM_HANDLE parent_handle;
  TPM2B_PUBLIC pub_out;
  TPML_PCR_SELECTION pcr_selection;
  InitSinglePcrSelection(pcr_num, TPM_ALG_SHA1, &pcr_selection);

  TPMA_OBJECT primary_flags;
  *(uint32_t*)(&primary_flags) = 0;
  primary_flags.fixedTPM = 1;
  primary_flags.fixedParent = 1;
  primary_flags.sensitiveDataOrigin = 1;
  primary_flags.userWithAuth = 1;
  primary_flags.decrypt = 1;
  primary_flags.restricted = 1;

  if (Tpm2_CreatePrimary(tpm, TPM_RH_OWNER, authString, pcr_selection, 
                         TPM_ALG_RSA, TPM_ALG_SHA1, primary_flags,
                         TPM_ALG_AES, 128, TPM_ALG_CFB, TPM_ALG_NULL,
                         1024, 0x010001,
                         &parent_handle, &pub_out)) {
    printf("CreatePrimary succeeded\n");
  }

  if (pcr_num >= 0) {
    uint16_t size_eventData = 3;
    byte_t eventData[3] = {1, 2, 3};
    if (Tpm2_PCR_Event(tpm, pcr_num, size_eventData, eventData)) {
      printf("Tpm2_PCR_Event succeeded\n");
    } else {
      printf("Tpm2_PCR_Event failed\n");
    }
  }

  TPM2B_CREATION_DATA creation_out;
  TPMT_TK_CREATION creation_ticket;
  int size_public = MAX_SIZE_PARAMS;
  byte_t out_public[MAX_SIZE_PARAMS];
  int size_private = MAX_SIZE_PARAMS;
  byte_t out_private[MAX_SIZE_PARAMS];
  TPM2B_DIGEST digest_out;

  TPMA_OBJECT create_flags;
  *(uint32_t*)(&create_flags) = 0;
  create_flags.fixedTPM = 1;
  create_flags.fixedParent = 1;
  create_flags.sensitiveDataOrigin = 1;
  create_flags.userWithAuth = 1;
  create_flags.sign = 1;
  create_flags.restricted = 1;

  if (Tpm2_CreateKey(tpm, parent_handle, parentAuth, authString, pcr_selection,
                     TPM_ALG_RSA, TPM_ALG_SHA1, create_flags, TPM_ALG_NULL,
                     (TPMI_AES_KEY_BITS)0, TPM_ALG_ECB, TPM_ALG_RSASSA,
                     1024, 0x010001,
                     &size_public, out_public, &size_private, out_private,
                     &creation_out, &digest_out, &creation_ticket)) {
    printf("Create succeeded, private size: %d, public size: %d\n",
           size_private, size_public);
  }

  TPM_HANDLE load_handle;
  TPM2B_NAME name;
  if (Tpm2_Load(tpm, parent_handle, parentAuth, size_public, out_public,
               size_private, out_private, &load_handle, &name)) {
    printf("Load succeeded\n");
  }

  TPM2B_DATA to_quote;
  to_quote.size = 16;
  for  (int i = 0; i < 16; i++)
    to_quote.buffer[i] = (byte_t)(i + 1);
  TPMT_SIG_SCHEME scheme;

  int quote_size = MAX_SIZE_PARAMS;
  byte_t quoted[MAX_SIZE_PARAMS];
  int sig_size = MAX_SIZE_PARAMS;
  byte_t sig[MAX_SIZE_PARAMS];
  if (!Tpm2_Quote(tpm, load_handle, parentAuth,
                  to_quote.size, to_quote.buffer,
                  scheme, pcr_selection, TPM_ALG_RSA, TPM_ALG_SHA1,
                  &quote_size, quoted, &sig_size, sig)) {
    printf("Quote failed\n");
    Tpm2_FlushContext(tpm, load_handle);
    Tpm2_FlushContext(tpm, parent_handle);
    return false;
  }
  printf("Quote succeeded, quoted (%d): ", quote_size); 
  PrintBytes(quote_size, quoted);
  printf("\n"); 
  printf("Sig (%d): ", sig_size); 
  PrintBytes(sig_size, sig);
  printf("\n"); 
  Tpm2_FlushContext(tpm, load_handle);
  Tpm2_FlushContext(tpm, parent_handle);
  return true;
}

void seperate_key_test() {
  RSA* rsa_key = RSA_generate_key(2048, 0x010001ULL, nullptr, nullptr);
  if (rsa_key == nullptr) {
    printf("Can't generate RSA key\n");
    return;
  }
  TPM2B_DIGEST secret;
  TPM2B_ENCRYPTED_SECRET salt;
  secret.size = 20;
  memcpy(secret.buffer, (byte_t*)"12345678901234567890", secret.size);

// Encrypt salt
  printf("\nencrypting salt\n");
  int size_padded_secret= 256;
  byte_t padded_secret[256];
  RSA_padding_add_PKCS1_OAEP(padded_secret, 256, secret.buffer, secret.size,
      (byte_t*)"SECRET", strlen("SECRET")+1);
  int n = RSA_public_encrypt(size_padded_secret, padded_secret, salt.secret,
                             rsa_key, RSA_NO_PADDING);
  salt.size = n;

  byte_t decrypted_with_pad[512];
  byte_t recovered_secret[512];
  memset(recovered_secret, 0, 512);
  memset(decrypted_with_pad, 0, 512);

  printf("\nEncrypted salt (%d): ", n);
  PrintBytes(n, salt.secret); printf("\n");
  int m = RSA_private_decrypt(n, (byte_t*) salt.secret,
               (byte_t*)decrypted_with_pad, rsa_key,
               RSA_NO_PADDING);
  if (m < 0) {
    printf("Can't decrypt\n");
    return;
  }
  printf("decrypted(%d): ", m);
  PrintBytes(m, decrypted_with_pad);printf("\n");
  salt.size = m;
  int k = 0;
  while(k < 256 && decrypted_with_pad[k] == 0) k++;
  RSA_padding_check_PKCS1_OAEP(recovered_secret, 256, 
      &decrypted_with_pad[k], 256-k, 256,
      (byte_t*)"SECRET", strlen("SECRET")+1);
}

// For Jethro
bool Tpm2_NvCombinedSessionTest(LocalTpm& tpm) {
  printf("Tpm2_NvCombinedSessionTest\n\n");
  extern int CreatePasswordAuthArea(string& password, int size, byte_t* buf);

  int slot = 1000;
  string authString("01020304");
  uint16_t size_data = 8;
  uint16_t size_out = 512;
  byte_t data_out[512];
  TPM_HANDLE nv_handle = GetNvHandle(slot);
  bool ret = true;

  TPM2B_ENCRYPTED_SECRET salt;
  TPM_HANDLE sessionHandle = 0;
  TPML_PCR_SELECTION pcrSelect;
  memset((void*)&pcrSelect, 0, sizeof(TPML_PCR_SELECTION));

  TPM2B_DIGEST secret;
  ProtectedSessionAuthInfo authInfo;
  TPMT_SYM_DEF symmetric;

  authInfo.hash_alg_ = TPM_ALG_SHA1;
  int hashSize = SizeHash(authInfo.hash_alg_);

  // If encryption.
  symmetric.algorithm = TPM_ALG_AES;
  symmetric.keyBits.aes = 128;
  symmetric.mode.aes = TPM_ALG_CFB;

  authInfo.targetAuthValue_.size = authString.size();
  memset(authInfo.targetAuthValue_.buffer, 0, authString.size());

  authInfo.newNonce_.size = hashSize;
  authInfo.oldNonce_.size = hashSize;
  memset(authInfo.newNonce_.buffer, 0, hashSize);
  memset(authInfo.oldNonce_.buffer, 0, hashSize);
  RAND_bytes(authInfo.oldNonce_.buffer, authInfo.oldNonce_.size);

  memset(secret.buffer, 0, 32);
  secret.size = 20;
  RAND_bytes(secret.buffer, secret.size);

  // Get endorsement key handle
  string emptyAuth;
  TPM_HANDLE ekHandle;
  TPM2B_PUBLIC pub_out;

  // TPM_RH_ENDORSEMENT
  TPMA_OBJECT primary_flags;
  *(uint32_t*)(&primary_flags) = 0;
  primary_flags.fixedTPM = 1;
  primary_flags.fixedParent = 1;
  primary_flags.sensitiveDataOrigin = 1;
  primary_flags.userWithAuth = 1;
  primary_flags.decrypt = 1;
  primary_flags.restricted = 1;

  // Get rid of the old counter.
  if (Tpm2_UndefineSpace(tpm, TPM_RH_OWNER, nv_handle)) {
    printf("Tpm2_UndefineSpace %d succeeds\n", slot);
  } else {
    printf("Tpm2_UndefineSpace fails (but that's OK usually)\n");
  }
  if (Tpm2_DefineSpace(tpm, TPM_RH_OWNER, nv_handle, authString,
                        0, nullptr, NV_COUNTER | NV_AUTHWRITE | NV_AUTHREAD,
                        size_data)) {
     printf("DefineSpace succeeded\n");
   } else {
     printf("DefineSpace failed\n");
     return false;
   }
  if (Tpm2_IncrementNv(tpm, nv_handle, authString)) {
    printf("Initial Tpm2_IncrementNv succeeds\n");
  } else {
    printf("Initial Tpm2_IncrementNv fails\n");
     return false;
  }

  // Get endorsement key.
  if (Tpm2_CreatePrimary(tpm, TPM_RH_ENDORSEMENT, emptyAuth, pcrSelect,
                         TPM_ALG_RSA, TPM_ALG_SHA1, primary_flags,
                         TPM_ALG_AES, 128, TPM_ALG_CFB, TPM_ALG_NULL,
                         2048, 0x010001, &ekHandle, &pub_out)) {
    printf("CreatePrimary succeeded: %08x\n", ekHandle);
  } else {
    printf("CreatePrimary failed\n");
    return false;
  }

  TPM2B_NAME pub_name;
  TPM2B_NAME qualified_pub_name;
  uint16_t pub_blob_size = 2048;
  byte_t pub_blob[2048];

  if (Tpm2_ReadPublic(tpm, ekHandle, &pub_blob_size, pub_blob, &pub_out,
                      &pub_name, &qualified_pub_name)) {
    printf("ReadPublic succeeded\n");
  } else {
    printf("ReadPublic failed\n");
    return false;
  }

  // Normally, the caller would get the key from the endorsement certificate
  EVP_PKEY* tpmKey = EVP_PKEY_new();
  RSA* rsa_tpmKey = RSA_new();
  BIGNUM* m = bin_to_BN((int)pub_out.publicArea.unique.rsa.size,
                        pub_out.publicArea.unique.rsa.buffer);
  uint64_t exp = 0x010001ULL;
  byte_t b_exp[16];
  ChangeEndian64((uint64_t*)&exp, (uint64_t*)b_exp);
  BIGNUM* e = bin_to_BN(sizeof(uint64_t), b_exp);
  if (1 != RSA_set0_key(rsa_tpmKey, m, e, nullptr)) {
    printf("RSA_set0_key failed\n");
    return false;
  }
  EVP_PKEY_assign_RSA(tpmKey, rsa_tpmKey);

  // Encrypt salt
  byte_t padded_secret[1024];
  memset(padded_secret, 0, 1024);
  RSA_padding_add_PKCS1_OAEP(padded_secret, 256,
      secret.buffer, secret.size,
      (byte_t*)"SECRET", strlen("SECRET")+1);
  int n = RSA_public_encrypt(256, padded_secret, salt.secret,
                             rsa_tpmKey, RSA_NO_PADDING);
  salt.size = n;

  authInfo.protectedHandle_ = nv_handle;
  authInfo.protectedAttributes_ = NV_COUNTER | NV_AUTHWRITE | NV_AUTHREAD;
  authInfo.protectedSize_ = size_data;
  authInfo.hash_alg_ = TPM_ALG_SHA1;
  authInfo.tpmSessionAttributes_ = CONTINUESESSION;
  extern int SetPasswordData(string& password, int size, byte_t* buf);
  byte_t tbuf[128];
  int l = SetPasswordData(authString, 128, tbuf);
  authInfo.targetAuthValue_.size = l - 2;
  memcpy(authInfo.targetAuthValue_.buffer, &tbuf[2], l - 2);
  
  // Start auth session.
    if (Tpm2_StartProtectedAuthSession(tpm, ekHandle, TPM_RH_NULL, authInfo,
         salt, TPM_SE_HMAC, symmetric, authInfo.hash_alg_, &sessionHandle)) {
    printf("Tpm2_StartProtectedAuthSession succeeds handle: %08x\n",
           sessionHandle);
  } else {
    printf("Tpm2_StartProtectedAuthSession fails\n");
    ret = false;
    goto done;
  }
  authInfo.sessionHandle_ = sessionHandle;

  // Calculate session key.
  if (!CalculateSessionKey(authInfo, secret)) {
    printf("Can't calculate HMac session key\n");
    ret = false;
    goto done;
  }

  if (Tpm2_IncrementProtectedNv(tpm, nv_handle, authInfo)) {
    printf("Tpm2_IncrementProtectedNv %d succeeds\n", nv_handle);
  }

  size_out = 8;
  if (Tpm2_ReadProtectedNv(tpm, nv_handle, authInfo, &size_out, data_out)) {
    printf("Tpm2_ReadProtectedNv %d succeeds: ", nv_handle);
    PrintBytes(size_out, data_out);
    printf("\n");
  }

done:
  if (sessionHandle != 0) {
    Tpm2_FlushContext(tpm, sessionHandle);
  }
  if (ekHandle != 0) {
    Tpm2_FlushContext(tpm, ekHandle);
  }
  return ret;
}
