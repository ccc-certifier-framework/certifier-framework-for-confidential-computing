export XDG_CONFIG_HOME="/home/jlm/.config"
echo $XDG_CONFIG_HOME

swtpm_setup --tpm2 --tpmstate ${XDG_CONFIG_HOME}/mytpm1 --create-ek-cert --create-platform-cert --lock-nvram

export TPM2TOOLS_TCTI="swtpm:port=2321"
swtpm socket --tpmstate dir=<swtpm_path> --tpm2 --server type=tcp,port=2321 --ctrl type=tcp,port=2322 --flags not-need-init,startup-clear

export TPM2TOOLS_TCTI="swtpm:path=/tmp/my_swtpm_dir/swtpm-sock"
tpm2_pcrread sha256
It can interact via a character device path (e.g., /dev/vtpm) 


PCR commands:
TPM2_PCR_Extend, TPM2_PCR_Event, TPM2_Read, TPM2_Reset, TPRM2_Allocate, TPM2_SetAuthorizationPolicy, TPM2_SetAuthorizationValue.

Seal
    1. Construct policy using tpm2_createpolicy, TPM2_policypcr
    2. TPM2_GetRandom to generate key
    3. TPM2_Create to specify policy and key

Unseal
    1. Start Session Auth
    2. TPM2_Load
    3. PolicyPCR
    4. TPM2_Unseal (with blob from Create)
    5. Close session: tpm2_flushcontext

Quote
    1. Policy
    2. Use TPM_GENERATED
    3. Specify qualified name
    4. Specify extra data
    5. FW
    6. Clock
    7. PCR numbers
    8. Digest of PCRs
    9. TPM2_Quote
    10. You have to reload these


in /usr/bin

tpm2_activatecredential
tpm2_certify
tpm2_certifycreation
tpm2_certifyX509certutil
tpm2_changeauth
tpm2_changeeps
tpm2_changepps
tpm2_checkquote
tpm2_clear
tpm2_clearcontrol
tpm2_clockrateadjust
tpm2_commit
tpm2_create
tpm2_createak
tpm2_createek
tpm2_createpolicy
tpm2_createprimary
tpm2_dictionarylockout
tpm2_duplicate
tpm2_ecdhkeygen
tpm2_ecdhzgen
tpm2_ecephemeral
tpm2_encodeobject
tpm2_encryptdecrypt
tpm2_eventlog
tpm2_evictcontrol
tpm2_flushcontext
tpm2_getcap
tpm2_getcommandauditdigest
tpm2_geteccparameters
tpm2_getekcertificate
tpm2_getpolicydigest
tpm2_getrandom --hex 32
tpm2_getsessionauditdigest
tpm2_gettestresult
tpm2_gettime
tpm2_hash
tpm2_hierarchycontrol
tpm2_hmac
tpm2_import
tpm2_incrementalselftest
tpm2_load
tpm2_loadexternal
tpm2_makecredential
tpm2_nvcertify
tpm2_nvdefine
tpm2_nvextend
tpm2_nvincrement
tpm2_nvread
tpm2_nvreadlock
tpm2_nvreadpublic
tpm2_nvsetbits
tpm2_nvundefine
tpm2_nvwrite
tpm2_nvwritelock
tpm2_pcrallocate
tpm2_pcrevent
tpm2_pcrextend
tpm2_pcrread
tpm2_pcrreset
tpm2_policyauthorize
tpm2_policyauthorizenv
tpm2_policyauthvalue
tpm2_policycommandcode
tpm2_policycountertimer
tpm2_policycphash
tpm2_policyduplicationselect
tpm2_policylocality
tpm2_policynamehash
tpm2_policynv
tpm2_policynvwritten
tpm2_policyor
tpm2_policypassword
tpm2_policypcr
tpm2_policyrestart
tpm2_policysecret
tpm2_policysigned
tpm2_policytemplate
tpm2_policyticket
tpm2_print
tpm2_quote
tpm2_rc_decode
tpm2_readclock
tpm2_readpublic
tpm2_rsadecrypt
tpm2_rsaencrypt
tpm2_selftest
tpm2_send
tpm2_sessionconfig
tpm2_setclock
tpm2_setcommandauditstatus
tpm2_setprimarypolicy
tpm2_shutdown
tpm2_sign
tpm2_startauthsession
tpm2_startup
tpm2_stirrandom
tpm2_testparms
tpm2_tr_encode
tpm2_unseal
tpm2_verifysignature
tpm2_zgen2phase

tpm2_getrandom --hex 32
tpm2_readclock
tpm2_pcrread sha256

tpm2_createpolicy [ -L | --policy=<value>] [ -g | --policy-algorithm=<value>]
  [ -l | --pcr-list=<value>] [ -f | --pcr=<value>]
  [ --policy-pcr] [ --policy-session]
tpm2_policypcr [ -L | --policy=<value>] [ -f | --pcr=<value>]
  [ -l | --pcr-list=<value>] [ -S | --session=<value>]
tpm2_load [ -P | --auth=<value>] [ -u | --public=<value>]
  [ -r | --private=<value>] [ -n | --name=<value>]
  [ -c | --key-context=<value>] [ -C | --parent-context=<value>]
  [ --cphash=<value>]
tpm2_createprimary  [ -C | --hierarchy=<value>]
  [ -P | --hierarchy-auth=<value>] [ -p | --key-auth=<value>]
  [ -g | --hash-algorithm=<value>] [ -G | --key-algorithm=<value>]
  [ -c | --key-context=<value>] [ -L | --policy=<value>]
  [ -a | --attributes=<value>] [ -u | --unique-data=<value>]
  [ --creation-data=<value>] [ --template-data=<value>]
  [ -t | --creation-ticket=<value>] [ -d | --creation-hash=<value>]
  [ -q | --outside-info=<value>] [ -l | --pcr-list=<value>] [ --cphash=<value>]
  [ -f | --format=<value>] [ -o | --output=<value>]
tpm2_create [ -P | --parent-auth=<value>] [ -p | --key-auth=<value>]
  [ -g | --hash-algorithm=<value>] [ -G | --key-algorithm=<value>]
  [ -a | --attributes=<value>] [ -i | --sealing-input=<value>]
  [ -L | --policy=<value>] [ -u | --public=<value>]
  [ -r | --private=<value>] [ -C | --parent-context=<value>]
  [ -c | --key-context=<value>] [ --creation-data=<value>]
  [ --template-data=<value>] [ -t | --creation-ticket=<value>]
  [ -d | --creation-hash=<value>] [ -q | --outside-info=<value>]
  [ -l | --pcr-list=<value>] [ --cphash=<value>] [ --rphash=<value>]
  [ -S | --session=<value>] [ -f | --format=<value>] [ -o | --output=<value>]
tpm2_startauthsession [ --policy-session] [ --audit-session]
  [ --bind-context=<value>] [ --bind-auth=<value>]
  [ --tpmkey-context=<value>] [ --hmac-session]
  [ -g | --hash-algorithm=<value>] [ -G | --key-algorithm=<value>]
  [ -S | --session=<value>] [ -c | --key-context=<value>]
  [ -n | --name=<value>]
tpm2_unseal [ -p | --auth=<value>] [ -o | --output=<value>]
  [ -c | --object-context=<value>] [ --cphash=<value>]
  [ --rphash=<value>] [ -S | --session=<value>]
tmp2_quote [ -c | --key-context=<value>] [ -p | --auth=<value>]
  [ -l | --pcr-list=<value>] [ -q | --qualification=<value>]
  [ -s | --signature=<value>] [ -m | --message=<value>]
  [ -o | --pcr=<value>] [ -F | --pcrs_format=<value>]
  [ -f | --format=<value>] [ -g | --hash-algorithm=<value>]
  [ --cphash=<value>] [ --scheme=<value>]


Tpm2_StartAuthSession(LocalTpm& tpm, TPM_RH tpm_obj, TPM_RH bind_obj, TPM2B_NONCE& initial_nonce, TPM2B_ENCRYPTED_SECRET& salt, TPM_SE session_type, TPMT_SYM_DEF& symmetric, TPMI_ALG_HASH hash_alg, TPM_HANDLE* session_handle, TPM2B_NONCE* nonce_obj);
bool Tpm2_PolicyPcr(LocalTpm& tpm, TPM_HANDLE session_handle, TPM2B_DIGEST& expected_digest, TPML_PCR_SELECTION& pcr);

TPM2 Qualified Names are unique identifiers for TPM objects (keys, NV indices)
that include the hash of the parent object’s name in the hierarchy (e.g.,
Endorsement Hierarchy). This structure binds an object to its parent, ensuring
it belongs to a specific TPM, crucial for remote attestation and ensuring secure,
trusted key creation.

Definition: A qualified name is the name algorithm hash of the parent’s
qualified name concatenated with the object’s own name.

Purpose: It acts as proof that an object, such as an Attestation Key (AK),
was created under a specific parent object, typically the Endorsement Key (EK).

Hierarchy Binding: The qualified name chain extends from the object up to
the Primary Seed (e.g., Owner, Platform, or Endorsement Hierarchy),
allowing verification of the entire hierarchy.

Usage in Tools: tpm2_createak utilizes the -q option to record this,
verifying the key's ancestry. tpm2_readpublic is used to read this name.

Structure: Unlike a simple name, which is just the hash of the public
area, the qualified name includes the parent's information, providing
a secure, hierarchical, and verifiable identifier for keys. 


GetEndorsementKey.cc
  primary_flags.fixedTPM = 1;
  primary_flags.fixedParent = 1;
  primary_flags.sensitiveDataOrigin = 1;
  primary_flags.userWithAuth = 1;
  primary_flags.decrypt = 1;
  primary_flags.restricted = 1;
  InitSinglePcrSelection(7, hash_alg_id, &pcrSelect);
  if (Tpm2_CreatePrimary(tpm, TPM_RH_ENDORSEMENT, emptyAuth, pcrSelect,
                         TPM_ALG_RSA, hash_alg_id, primary_flags,
                         TPM_ALG_AES, 128, TPM_ALG_CFB, TPM_ALG_NULL,
                         2048, 0x010001, &ekHandle, &pub_out))
  Tpm2_ReadPublic(tpm, ekHandle, &pub_blob_size, pub_blob,
                      &pub_out, &pub_name, &qualified_pub_name)
  Tpm2_FlushContext(tpm, ekHandle);

  string authString("01020304");
  string parentAuth("01020304");
  string emptyAuth;
  TPML_PCR_SELECTION pcrSelect;
  TPMA_OBJECT root_flags;
  TPM2B_CREATION_DATA creation_out;
  TPM2B_DIGEST digest_out;
  TPMT_TK_CREATION creation_ticket;
  TPM_HANDLE root_handle = 0;
  TPM2B_PUBLIC root_pub_out;
  TPM_HANDLE seal_load_handle = 0;
  TPMA_OBJECT seal_create_flags;
  TPM2B_NAME seal_name;
  int seal_size_public = MAX_SIZE_PARAMS;
  byte seal_out_public[MAX_SIZE_PARAMS];
  int seal_size_private = MAX_SIZE_PARAMS;
  byte seal_out_private[MAX_SIZE_PARAMS];
  TPMA_OBJECT quote_create_flags;
  TPM2B_NAME quote_name;
  TPM_HANDLE quote_load_handle = 0;
  int quote_size_public = MAX_SIZE_PARAMS;
  byte quote_out_public[MAX_SIZE_PARAMS];
  int quote_size_private = MAX_SIZE_PARAMS;
  byte quote_out_private[MAX_SIZE_PARAMS];
  TPM_HANDLE nv_handle = 0;
  byte context_save_area[MAX_SIZE_PARAMS];
  uint16_t context_data_size = MAX_SIZE_PARAMS;
  TPM_HANDLE sealed_load_handle = 0;
  TPM_ALG_ID hash_alg_id;
  InitSinglePcrSelection(7, hash_alg_id, &pcrSelect);
  *(uint32_t*)(&root_flags) = 0;
  root_flags.fixedTPM = 1;
  root_flags.fixedParent = 1;
  root_flags.sensitiveDataOrigin = 1;
  root_flags.userWithAuth = 1;
  root_flags.decrypt = 1;
  root_flags.restricted = 1;
  if (Tpm2_CreatePrimary(tpm, TPM_RH_OWNER, authString, pcrSelect,
                         TPM_ALG_RSA, hash_alg_id, root_flags,
                         TPM_ALG_AES, 128, TPM_ALG_CFB, TPM_ALG_NULL,
                         2048, 0x010001, &root_handle, &root_pub_out)) 
 *(uint32_t*)(&seal_create_flags) = 0;
  seal_create_flags.fixedTPM = 1;
  seal_create_flags.fixedParent = 1;
  seal_create_flags.sensitiveDataOrigin = 1;
  seal_create_flags.userWithAuth = 1;
  seal_create_flags.sign = 1;

  if (Tpm2_CreateKey(tpm, root_handle, parentAuth, authString, pcrSelect,
                     TPM_ALG_RSA, hash_alg_id, seal_create_flags, TPM_ALG_NULL,
                     (TPMI_AES_KEY_BITS)0, TPM_ALG_ECB, TPM_ALG_RSASSA,
                     2048, 0x010001, &seal_size_public, seal_out_public,
                     &seal_size_private, seal_out_private,
                     &creation_out, &digest_out, &creation_ticket)) {
  if (Tpm2_Load(tpm, root_handle, parentAuth, seal_size_public,
                seal_out_public, seal_size_private, seal_out_private,
                &seal_load_handle, &seal_name)) {

  *(uint32_t*)(&quote_create_flags) = 0;
  quote_create_flags.fixedTPM = 1;
  quote_create_flags.fixedParent = 1;
  quote_create_flags.sensitiveDataOrigin = 1;
  quote_create_flags.userWithAuth = 1;
  quote_create_flags.sign = 1;
  quote_create_flags.restricted = 1;
  if (Tpm2_CreateKey(tpm, root_handle, parentAuth, authString, pcrSelect,
                     TPM_ALG_RSA, hash_alg_id, quote_create_flags, TPM_ALG_NULL,
                     (TPMI_AES_KEY_BITS)0, TPM_ALG_ECB, TPM_ALG_RSASSA,
                     1024, 0x010001,
                     &quote_size_public, quote_out_public,
                     &quote_size_private, quote_out_private,
                     &creation_out, &digest_out, &creation_ticket)) {
  if (Tpm2_Load(tpm, root_handle, parentAuth, quote_size_public,
                quote_out_public, quote_size_private, quote_out_private,
                &quote_load_handle, &quote_name)) {
  nv_handle = GetNvHandle(FLAGS_slot_primary);
  context_data_size = MAX_SIZE_PARAMS;
  if (!Tpm2_SaveContext(tpm, root_handle, &context_data_size,
                        context_save_area)) {
  Tpm2_UndefineSpace(tpm, TPM_RH_OWNER, nv_handle))
  if (!Tpm2_WriteNv(tpm, nv_handle, authString,
                    (uint16_t)context_data_size, context_save_area)){
  if (!Tpm2_SaveContext(tpm, seal_load_handle, &context_data_size,
                        context_save_area)) {

  if (!Tpm2_WriteNv(tpm, nv_handle, authString,
                    (uint16_t)context_data_size, context_save_area)){
  // Save quote context
  nv_handle = GetNvHandle(FLAGS_slot_quote);
  context_data_size = MAX_SIZE_PARAMS;
  if (!Tpm2_SaveContext(tpm, quote_load_handle, &context_data_size,
                        context_save_area)) {
  if (root_handle != 0) {
    Tpm2_FlushContext(tpm, root_handle);
  }
  if (seal_load_handle != 0) {
    Tpm2_FlushContext(tpm, seal_load_handle);
  }
  if (quote_load_handle != 0) {
    Tpm2_FlushContext(tpm, quote_load_handle);
  }
  if (sealed_load_handle != 0) {
    Tpm2_FlushContext(tpm, sealed_load_handle);
}

void InitSinglePcrSelection(int pcrNum, TPM_ALG_ID hash,
                            TPML_PCR_SELECTION* pcrSelect) {
  if (pcrNum == -1) {
    pcrSelect->count = 0; 
    return;
  }
  pcrSelect->count = 1;
  pcrSelect->pcrSelections[0].hash = hash;
  pcrSelect->pcrSelections[0].sizeofSelect = 3;
  for (int i = 0; i < 3; i++)
    pcrSelect->pcrSelections[0].pcrSelect[i] = 0;
  if (pcrNum != 0)
    setPcrBit(pcrNum, pcrSelect->pcrSelections[0].pcrSelect);
} 

bool Tpm2_SealCombinedTest(LocalTpm& tpm, int pcr_num) {
  string authString("01020304");
  string parentAuth("01020304");
  string emptyAuth;
  TPM_HANDLE parent_handle;
  TPM2B_PUBLIC pub_out;
  TPML_PCR_SELECTION pcrSelect;
  InitSinglePcrSelection(pcr_num, TPM_ALG_SHA1, &pcrSelect);
  TPMA_OBJECT primary_flags;
  *(uint32_t*)(&primary_flags) = 0;
  primary_flags.fixedTPM = 1;
  primary_flags.fixedParent = 1;
  primary_flags.sensitiveDataOrigin = 1;
  primary_flags.userWithAuth = 1;
  primary_flags.decrypt = 1;
  primary_flags.restricted = 1;

  if (Tpm2_CreatePrimary(tpm, TPM_RH_OWNER, authString, pcrSelect, 
                         TPM_ALG_RSA, TPM_ALG_SHA1, primary_flags,
                         TPM_ALG_AES, 128, TPM_ALG_CFB, TPM_ALG_NULL,
                         1024, 0x010001,
                        &parent_handle, &pub_out)) {
    printf("CreatePrimary succeeded\n");
  }
  
  TPM2B_DIGEST secret;
  secret.size = 16;
  for  (int i = 0; i < 16; i++)
    secret.buffer[i] = (byte_t)(i + 1);

  TPM2B_CREATION_DATA creation_out;
  TPMT_TK_CREATION creation_ticket;
  int size_public = MAX_SIZE_PARAMS;
  byte_t out_public[MAX_SIZE_PARAMS];
  int size_private = MAX_SIZE_PARAMS;
  byte_t out_private[MAX_SIZE_PARAMS];
  TPM2B_DIGEST digest_out;
  TPM2B_NONCE initial_nonce;
  TPM2B_ENCRYPTED_SECRET salt;
  TPMT_SYM_DEF symmetric;
  TPM_HANDLE session_handle;
  TPM2B_NONCE nonce_obj;

  initial_nonce.size = 16;
  memset(initial_nonce.buffer, 0, 16);
  salt.size = 0;
  symmetric.algorithm = TPM_ALG_NULL;
  
  // Start auth session
  if (Tpm2_StartAuthSession(tpm, TPM_RH_NULL, TPM_RH_NULL,
                            initial_nonce, salt, TPM_SE_POLICY,
                            symmetric, TPM_ALG_SHA1, &session_handle,
                            &nonce_obj)) {
    printf("Tpm2_StartAuthSession succeeds handle: %08x\n",
           session_handle);
    printf("nonce (%d): ", nonce_obj.size);
    PrintBytes(nonce_obj.size, nonce_obj.buffer);
    printf("\n");
  }

  TPM2B_DIGEST policy_digest;
  // get policy digest
  if(Tpm2_PolicyGetDigest(tpm, session_handle, &policy_digest)) {
    printf("PolicyGetDigest before Pcr succeeded: ");
    PrintBytes(policy_digest.size, policy_digest.buffer); printf("\n");
  }

  if (Tpm2_PolicyPassword(tpm, session_handle)) {
    printf("PolicyPassword succeeded\n");
  }

  TPM2B_DIGEST expected_digest;
  expected_digest.size = 0;
  if (Tpm2_PolicyPcr(tpm, session_handle,
                     expected_digest, pcrSelect)) {
    printf("PolicyPcr succeeded\n");
  }

  if(Tpm2_PolicyGetDigest(tpm, session_handle, &policy_digest)) {
    printf("PolicyGetDigest succeeded: ");
    PrintBytes(policy_digest.size, policy_digest.buffer); printf("\n");
  }

  TPMA_OBJECT create_flags;
  *(uint32_t*)(&create_flags) = 0;
  create_flags.fixedTPM = 1;
  create_flags.fixedParent = 1;

  if (Tpm2_CreateSealed(tpm, parent_handle, policy_digest.size,
                        policy_digest.buffer, parentAuth, secret.size,
                        secret.buffer, pcrSelect, TPM_ALG_SHA1, create_flags,
                        TPM_ALG_NULL, (TPMI_AES_KEY_BITS)0, TPM_ALG_ECB,
                        TPM_ALG_RSASSA, 1024, 0x010001,
                        &size_public, out_public, &size_private, out_private,
                        &creation_out, &digest_out, &creation_ticket)) {
    printf("Create with digest succeeded private size: %d, public size: %d\n",
           size_private, size_public);
  }

  TPM_HANDLE load_handle;
  TPM2B_NAME name;
  if (Tpm2_Load(tpm, parent_handle, parentAuth, size_public, out_public,
               size_private, out_private, &load_handle, &name)) {
    printf("Load succeeded\n");
  }

  int unsealed_size = MAX_SIZE_PARAMS;
  byte_t unsealed[MAX_SIZE_PARAMS];
  TPM2B_DIGEST hmac;
  hmac.size = 0;
  if (!Tpm2_Unseal(tpm, load_handle, parentAuth, session_handle,
                   nonce_obj, 0x01, hmac,
                   &unsealed_size, unsealed)) {
    printf("Unseal failed\n");
    Tpm2_FlushContext(tpm, session_handle);
    Tpm2_FlushContext(tpm, load_handle);
    return false;
  }
  printf("Unseal succeeded, unsealed (%d): ", unsealed_size); 
  PrintBytes(unsealed_size, unsealed);
  printf("\n"); 
  Tpm2_FlushContext(tpm, session_handle);
  Tpm2_FlushContext(tpm, load_handle);
  return true;
}

bool Tpm2_QuoteCombinedTest(LocalTpm& tpm, int pcr_num) {
  string authString("01020304");
  string parentAuth("01020304");
  string emptyAuth;

  TPM_HANDLE parent_handle;
  TPM2B_PUBLIC pub_out;
  TPML_PCR_SELECTION pcr_selection;
  InitSinglePcrSelection(pcr_num, TPM_ALG_SHA1, &pcr_selection);

  TPMA_OBJECT primary_flags;
  *(uint32_t*)(&primary_flags) = 0;
  primary_flags.fixedTPM = 1;
  primary_flags.fixedParent = 1;
  primary_flags.sensitiveDataOrigin = 1;
  primary_flags.userWithAuth = 1;
  primary_flags.decrypt = 1;
  primary_flags.restricted = 1;

  if (Tpm2_CreatePrimary(tpm, TPM_RH_OWNER, authString, pcr_selection, 
                         TPM_ALG_RSA, TPM_ALG_SHA1, primary_flags,
                         TPM_ALG_AES, 128, TPM_ALG_CFB, TPM_ALG_NULL,
                         1024, 0x010001,
                         &parent_handle, &pub_out)) {
    printf("CreatePrimary succeeded\n");
  }

  if (pcr_num >= 0) {
    uint16_t size_eventData = 3;
    byte_t eventData[3] = {1, 2, 3};
    if (Tpm2_PCR_Event(tpm, pcr_num, size_eventData, eventData)) {
      printf("Tpm2_PCR_Event succeeded\n");
    } else {
      printf("Tpm2_PCR_Event failed\n");
    }
  }

  TPM2B_CREATION_DATA creation_out;
  TPMT_TK_CREATION creation_ticket;
  int size_public = MAX_SIZE_PARAMS;
  byte_t out_public[MAX_SIZE_PARAMS];
  int size_private = MAX_SIZE_PARAMS;
  byte_t out_private[MAX_SIZE_PARAMS];
  TPM2B_DIGEST digest_out;

  TPMA_OBJECT create_flags;
  *(uint32_t*)(&create_flags) = 0;
  create_flags.fixedTPM = 1;
  create_flags.fixedParent = 1;
  create_flags.sensitiveDataOrigin = 1;
  create_flags.userWithAuth = 1;
  create_flags.sign = 1;
  create_flags.restricted = 1;

  if (Tpm2_CreateKey(tpm, parent_handle, parentAuth, authString, pcr_selection,
                     TPM_ALG_RSA, TPM_ALG_SHA1, create_flags, TPM_ALG_NULL,
                     (TPMI_AES_KEY_BITS)0, TPM_ALG_ECB, TPM_ALG_RSASSA,
                     1024, 0x010001,
                     &size_public, out_public, &size_private, out_private,
                     &creation_out, &digest_out, &creation_ticket)) {
    printf("Create succeeded, private size: %d, public size: %d\n",
           size_private, size_public);
  }

  TPM_HANDLE load_handle;
  TPM2B_NAME name;
  if (Tpm2_Load(tpm, parent_handle, parentAuth, size_public, out_public,
               size_private, out_private, &load_handle, &name)) {
    printf("Load succeeded\n");
  }

  TPM2B_DATA to_quote;
  to_quote.size = 16;
  for  (int i = 0; i < 16; i++)
    to_quote.buffer[i] = (byte_t)(i + 1);
  TPMT_SIG_SCHEME scheme;

  int quote_size = MAX_SIZE_PARAMS;
  byte_t quoted[MAX_SIZE_PARAMS];
  int sig_size = MAX_SIZE_PARAMS;
  byte_t sig[MAX_SIZE_PARAMS];
  if (!Tpm2_Quote(tpm, load_handle, parentAuth,
                  to_quote.size, to_quote.buffer,
                  scheme, pcr_selection, TPM_ALG_RSA, TPM_ALG_SHA1,
                  &quote_size, quoted, &sig_size, sig)) {
    printf("Quote failed\n");
    Tpm2_FlushContext(tpm, load_handle);
    Tpm2_FlushContext(tpm, parent_handle);
    return false;
  }
  printf("Quote succeeded, quoted (%d): ", quote_size); 
  PrintBytes(quote_size, quoted);
  printf("\n"); 
  printf("Sig (%d): ", sig_size); 
  PrintBytes(sig_size, sig);
  printf("\n"); 
  Tpm2_FlushContext(tpm, load_handle);
  Tpm2_FlushContext(tpm, parent_handle);
  return true;
}

--------------------------------------------------

Get endorsement
  flags: fixedTPM fixedParent sensitivedataorigin user-with-auth decrypt restricted
  tpm2_createprimary endorsement empty-auth pcr-select rsa-alg hash-id-alg flags 
    aes-alg cfb alg-null 2048 010001 &handle &pub-out
  tpm2_createkey root-handle sealed-out
  tpm2_load sealed-out creation-out &seal-load-handle ...
  tpm2-savecontext context-save-area
  tpm2-writenv context save area
  
sealtest
  tpm2_createprimary ... &parent_handle &pub-out
  tpm2-startauthsession RH_NULL RH_NULL initial-nonce salt SE_POLICY symmetric SHA &session-handle
    &nonce-obj
  tpm2_policygetdigest session-handle &policy-digest
  tpm2_policypassword session-handle
  tpm2_policypcr session-handle expected-digest pcr-select
  tpm2_createsealed parent-handle policy-digest parent-auth secret pcr-select hash-alg create-flags
    pub-out private-out digest-out ticket
  tpm2_load out-pub out-priv &load-handle &name
  tpm2_unseal load-handle parent-auth session-handle nonce 01 hmac &unsealed


quote
  tpm2_createprimary auth pcr-sel flags size &parent-handle &pub-out
  tpm2_pcrevent
  tpm2_createkey parent-handle parent-auth .. &pub &priv &create-out &digest-auth &&ticket-out
  tpm2_load parent-handle ... &load-handle &name
  tpm2_quote load-handle parent-auth to-quote scheme pcr-selection &quoted &sig


The following options are supported if the chardev interface is chosen:

       -c|--chardev <device path>
       --vtpm-proxy

XDG_CONFIG_HOME="/home/jlm/.config"
swtpm_setup --tpm2 --tpmstate ${XDG_CONFIG_HOME}/mytpm1 --create-ek-cert --create-platform-cert --lock-nvram
echo $XDG_CONFIG_HOME
/home/jlm/.config
export TPM2TOOLS_TCTI="swtpm:port=2321"
swtpm socket --tpmstate dir=<swtpm_path> --tpm2 --server type=tcp,port=2321 --ctrl type=tcp,port=2322 --flags not-need-init,startup-clear


export XDG_CONFIG_HOME="/home/jlm/.config"
sudo swtpm_setup --tpm2 --tpmstate ${XDG_CONFIG_HOME}/mytpm1 --create-ek-cert --create-platform-cert --lock-nvram
sudo swtpm chardev -c /dev/vtpm --vtpm-proxy --tpmstate dir=${XDG_CONFIG_HOME}/mytpm1 --tpm2 --ctrl type=tcp,port=2322

sudo swtpm chardev --vtpm-proxy --tpmstate dir=${XDG_CONFIG_HOME}/mytpm1 --tpm2 --ctrl type=unixio
/usr/bin/echo "capability sys_admin," > /etc/apparmor.d/local/usr.bin.swtpm
/usr/bin/echo "capability sys_admin," > /etc/apparmor.d/local/usr.bin.swtpm
aa-enforce /usr/bin/swtpm

modprobe tpm_vtpm_proxy
swtpm chardev --vtpm-proxy --tpmstate dir=... --tpm2 ...

mkdir -p /tmp/my_swtpm_dir
swtpm_setup --tpm2 --tpmstate ${XDG_CONFIG_HOME}/mytpm1 --create-ek-cert --create-platform-cert --lock-nvram


---------------------------

sudo apt-get install apparmor-utils

Start:

export XDG_CONFIG_HOME="/home/jlm/.config"
echo $XDG_CONFIG_HOME

sudo aa-complain /usr/bin/swtpm
sudo apparmor_parser -r /etc/apparmor.d/usr.bin.swtpm

sudo swtpm_setup --tpm2 --tpmstate ${XDG_CONFIG_HOME}/mytpm1 --create-ek-cert --create-platform-cert --lock-nvram

sudo swtpm socket --tpmstate dir=${XDG_CONFIG_HOME}/mytpm1 --tpm2 --server type=tcp,port=2321 --ctrl type=tcp,port=2322 --flags not-need-init,startup-clear

sudo swtpm chardev --vtpm-proxy --tpmstate dir=${XDG_CONFIG_HOME}/mytpm1 --tpm2 --ctrl type=tcp,port=2322 &

sudo ./tpm2_util.exe --tpm_device="/dev/tpm1" --command=GetRandom --numbytes=32
sudo ./tpm2_util.exe --tpm_device="/dev/tpm1" --command=EndorsementTest
sudo ./tpm2_util.exe --tpm_device="/dev/tpm1" --command=ContextTest
sudo ./tpm2_util.exe --tpm_device="/dev/tpm1" --pcr_num=7 --command=SealTest
sudo ./tpm2_util.exe --tpm_device="/dev/tpm1" --command=KeyTest
sudo ./tpm2_util.exe --tpm_device="/dev/tpm1" --command=NvTest
sudo ./tpm2_util.exe --tpm_device="/dev/tpm1" --pcr_num=7 --command=QuoteTest

----------------------------

