export XDG_CONFIG_HOME="/home/jlm/.config"
echo $XDG_CONFIG_HOME

swtpm_setup --tpm2 --tpmstate ${XDG_CONFIG_HOME}/mytpm1 --create-ek-cert --create-platform-cert --lock-nvram

export TPM2TOOLS_TCTI="swtpm:port=2321"
swtpm socket --tpmstate dir=<swtpm_path> --tpm2 --server type=tcp,port=2321 --ctrl type=tcp,port=2322 --flags not-need-init,startup-clear

export TPM2TOOLS_TCTI="swtpm:path=/tmp/my_swtpm_dir/swtpm-sock"
tpm2_pcrread sha256
It can interact via a character device path (e.g., /dev/vtpm) 


PCR commands:
TPM2_PCR_Extend, TPM2_PCR_Event, TPM2_Read, TPM2_Reset, TPRM2_Allocate, TPM2_SetAuthorizationPolicy, TPM2_SetAuthorizationValue.

Seal
    1. Construct policy using tpm2_createpolicy, TPM2_policypcr
    2. TPM2_GetRandom to generate key
    3. TPM2_Create to specify policy and key

Unseal
    1. Start Session Auth
    2. TPM2_Load
    3. PolicyPCR
    4. TPM2_Unseal (with blob from Create)
    5. Close session: tpm2_flushcontext

Quote
    1. Policy
    2. Use TPM_GENERATED
    3. Specify qualified name
    4. Specify extra data
    5. FW
    6. Clock
    7. PCR numbers
    8. Digest of PCRs
    9. TPM2_Quote
    10. You have to reload these


in /usr/bin

tpm2_activatecredential
tpm2_certify
tpm2_certifycreation
tpm2_certifyX509certutil
tpm2_changeauth
tpm2_changeeps
tpm2_changepps
tpm2_checkquote
tpm2_clear
tpm2_clearcontrol
tpm2_clockrateadjust
tpm2_commit
tpm2_create
tpm2_createak
tpm2_createek
tpm2_createpolicy
tpm2_createprimary
tpm2_dictionarylockout
tpm2_duplicate
tpm2_ecdhkeygen
tpm2_ecdhzgen
tpm2_ecephemeral
tpm2_encodeobject
tpm2_encryptdecrypt
tpm2_eventlog
tpm2_evictcontrol
tpm2_flushcontext
tpm2_getcap
tpm2_getcommandauditdigest
tpm2_geteccparameters
tpm2_getekcertificate
tpm2_getpolicydigest
tpm2_getrandom --hex 32
tpm2_getsessionauditdigest
tpm2_gettestresult
tpm2_gettime
tpm2_hash
tpm2_hierarchycontrol
tpm2_hmac
tpm2_import
tpm2_incrementalselftest
tpm2_load
tpm2_loadexternal
tpm2_makecredential
tpm2_nvcertify
tpm2_nvdefine
tpm2_nvextend
tpm2_nvincrement
tpm2_nvread
tpm2_nvreadlock
tpm2_nvreadpublic
tpm2_nvsetbits
tpm2_nvundefine
tpm2_nvwrite
tpm2_nvwritelock
tpm2_pcrallocate
tpm2_pcrevent
tpm2_pcrextend
tpm2_pcrread
tpm2_pcrreset
tpm2_policyauthorize
tpm2_policyauthorizenv
tpm2_policyauthvalue
tpm2_policycommandcode
tpm2_policycountertimer
tpm2_policycphash
tpm2_policyduplicationselect
tpm2_policylocality
tpm2_policynamehash
tpm2_policynv
tpm2_policynvwritten
tpm2_policyor
tpm2_policypassword
tpm2_policypcr
tpm2_policyrestart
tpm2_policysecret
tpm2_policysigned
tpm2_policytemplate
tpm2_policyticket
tpm2_print
tpm2_quote
tpm2_rc_decode
tpm2_readclock
tpm2_readpublic
tpm2_rsadecrypt
tpm2_rsaencrypt
tpm2_selftest
tpm2_send
tpm2_sessionconfig
tpm2_setclock
tpm2_setcommandauditstatus
tpm2_setprimarypolicy
tpm2_shutdown
tpm2_sign
tpm2_startauthsession
tpm2_startup
tpm2_stirrandom
tpm2_testparms
tpm2_tr_encode
tpm2_unseal
tpm2_verifysignature
tpm2_zgen2phase

tpm2_getrandom --hex 32
tpm2_readclock
tpm2_pcrread sha256

tpm2_createpolicy [ -L | --policy=<value>] [ -g | --policy-algorithm=<value>]
  [ -l | --pcr-list=<value>] [ -f | --pcr=<value>]
  [ --policy-pcr] [ --policy-session]
tpm2_policypcr [ -L | --policy=<value>] [ -f | --pcr=<value>]
  [ -l | --pcr-list=<value>] [ -S | --session=<value>]
tpm2_load [ -P | --auth=<value>] [ -u | --public=<value>]
  [ -r | --private=<value>] [ -n | --name=<value>]
  [ -c | --key-context=<value>] [ -C | --parent-context=<value>]
  [ --cphash=<value>]
tpm2_createprimary  [ -C | --hierarchy=<value>]
  [ -P | --hierarchy-auth=<value>] [ -p | --key-auth=<value>]
  [ -g | --hash-algorithm=<value>] [ -G | --key-algorithm=<value>]
  [ -c | --key-context=<value>] [ -L | --policy=<value>]
  [ -a | --attributes=<value>] [ -u | --unique-data=<value>]
  [ --creation-data=<value>] [ --template-data=<value>]
  [ -t | --creation-ticket=<value>] [ -d | --creation-hash=<value>]
  [ -q | --outside-info=<value>] [ -l | --pcr-list=<value>] [ --cphash=<value>]
  [ -f | --format=<value>] [ -o | --output=<value>]
tpm2_create [ -P | --parent-auth=<value>] [ -p | --key-auth=<value>]
  [ -g | --hash-algorithm=<value>] [ -G | --key-algorithm=<value>]
  [ -a | --attributes=<value>] [ -i | --sealing-input=<value>]
  [ -L | --policy=<value>] [ -u | --public=<value>]
  [ -r | --private=<value>] [ -C | --parent-context=<value>]
  [ -c | --key-context=<value>] [ --creation-data=<value>]
  [ --template-data=<value>] [ -t | --creation-ticket=<value>]
  [ -d | --creation-hash=<value>] [ -q | --outside-info=<value>]
  [ -l | --pcr-list=<value>] [ --cphash=<value>] [ --rphash=<value>]
  [ -S | --session=<value>] [ -f | --format=<value>] [ -o | --output=<value>]
tpm2_startauthsession [ --policy-session] [ --audit-session]
  [ --bind-context=<value>] [ --bind-auth=<value>]
  [ --tpmkey-context=<value>] [ --hmac-session]
  [ -g | --hash-algorithm=<value>] [ -G | --key-algorithm=<value>]
  [ -S | --session=<value>] [ -c | --key-context=<value>]
  [ -n | --name=<value>]
tpm2_unseal [ -p | --auth=<value>] [ -o | --output=<value>]
  [ -c | --object-context=<value>] [ --cphash=<value>]
  [ --rphash=<value>] [ -S | --session=<value>]
tmp2_quote [ -c | --key-context=<value>] [ -p | --auth=<value>]
  [ -l | --pcr-list=<value>] [ -q | --qualification=<value>]
  [ -s | --signature=<value>] [ -m | --message=<value>]
  [ -o | --pcr=<value>] [ -F | --pcrs_format=<value>]
  [ -f | --format=<value>] [ -g | --hash-algorithm=<value>]
  [ --cphash=<value>] [ --scheme=<value>]


Tpm2_StartAuthSession(LocalTpm& tpm, TPM_RH tpm_obj, TPM_RH bind_obj, TPM2B_NONCE& initial_nonce, TPM2B_ENCRYPTED_SECRET& salt, TPM_SE session_type, TPMT_SYM_DEF& symmetric, TPMI_ALG_HASH hash_alg, TPM_HANDLE* session_handle, TPM2B_NONCE* nonce_obj);
bool Tpm2_PolicyPcr(LocalTpm& tpm, TPM_HANDLE session_handle, TPM2B_DIGEST& expected_digest, TPML_PCR_SELECTION& pcr);

TPM2 Qualified Names are unique identifiers for TPM objects (keys, NV indices)
that include the hash of the parent object’s name in the hierarchy (e.g.,
Endorsement Hierarchy). This structure binds an object to its parent, ensuring
it belongs to a specific TPM, crucial for remote attestation and ensuring secure,
trusted key creation.

Definition: A qualified name is the name algorithm hash of the parent’s
qualified name concatenated with the object’s own name.

Purpose: It acts as proof that an object, such as an Attestation Key (AK),
was created under a specific parent object, typically the Endorsement Key (EK).

Hierarchy Binding: The qualified name chain extends from the object up to
the Primary Seed (e.g., Owner, Platform, or Endorsement Hierarchy),
allowing verification of the entire hierarchy.

Usage in Tools: tpm2_createak utilizes the -q option to record this,
verifying the key's ancestry. tpm2_readpublic is used to read this name.

Structure: Unlike a simple name, which is just the hash of the public
area, the qualified name includes the parent's information, providing
a secure, hierarchical, and verifiable identifier for keys. 

-------------------------------------------------------------------------------

This just covers how we go from a vendor-certified EK to quoting key that CF can use.  Endorsement_test is close to what we will need.

 

The TPM “comes with” a certified restricted decryption key that we call the endorsement key (EK).  Restricted means that it can only be used for certain purposes.  The one we care about is ActivateCredential

 

The endorsement key is not usually TPM resident: it’s deterministically generated based on input parameters (what sort of key we want) and the endorsement seed (which we can assume never changes.) 

 

This is what is happening at line 508.

 

Note that you ReadPublic shortly after: you should be able to match this pubkey with the cert that you found in NV storage.

 

You make the quoting key at line 590.  You have made it a child of a “storage root key” that is created earlier (line 562).  Making your quoting key a child of the storage root key means that after reboot you can recreate the SRK (deterministic) and then load the key blob that you got at line 590.

 

Now we want to cryptographically link the quoting key to the EK.

 

The cryptographic operation public key decryption with the EK, but rather than the server simply encrypting a secret, it encrypts a secret PLUS the public key of the quoting key we’re trying to get certified (there’s other stuff too.)  Creating the blob (secret+thing-to-check) can be done with library code or using the TPM helper function MakeCredential.

 

We get to choose how we use this ActivateCredential function, but the simplest thing would be:

 

Client sends EK, EK-cred, pub-key of newly created (but not yet certified) quoting key to server
Server checks the EK cert chai.  If OK
The server creates a certificate for the quoting key based on whatever root it wants to use.            
It then creates a random symmetric encryption key
And encrypts the certificate
The server uses MakeCredential (or a library function) to create an encrypted blob containing the symmetric key 3(b)
This blob is send to the client (as well as the now-encrypted cert
The client calls ActivateCredential
If this succeeds, the client can now decrypt the cert for the quoting key
 

On reboot, client code must recreate the SRK as before (line 562) and Load() the qutoting key, like line 604

 

It can then quote with this key.

 

I can walk you through the other stuff, but that’s the tricky one


--------------------------------------------------

Get endorsement
  flags: fixedTPM fixedParent sensitivedataorigin user-with-auth decrypt restricted
  tpm2_createprimary endorsement empty-auth pcr-select rsa-alg hash-id-alg flags 
    aes-alg cfb alg-null 2048 010001 &handle &pub-out
  tpm2_createkey root-handle sealed-out
  tpm2_load sealed-out creation-out &seal-load-handle ...
  tpm2-savecontext context-save-area
  tpm2-writenv context save area
  
sealtest
  tpm2_createprimary ... &parent_handle &pub-out
  tpm2-startauthsession RH_NULL RH_NULL initial-nonce salt SE_POLICY symmetric SHA &session-handle
    &nonce-obj
  tpm2_policygetdigest session-handle &policy-digest
  tpm2_policypassword session-handle
  tpm2_policypcr session-handle expected-digest pcr-select
  tpm2_createsealed parent-handle policy-digest parent-auth secret pcr-select hash-alg create-flags
    pub-out private-out digest-out ticket
  tpm2_load out-pub out-priv &load-handle &name
  tpm2_unseal load-handle parent-auth session-handle nonce 01 hmac &unsealed


quote
  tpm2_createprimary auth pcr-sel flags size &parent-handle &pub-out
  tpm2_pcrevent
  tpm2_createkey parent-handle parent-auth .. &pub &priv &create-out &digest-auth &&ticket-out
  tpm2_load parent-handle ... &load-handle &name
  tpm2_quote load-handle parent-auth to-quote scheme pcr-selection &quoted &sig


The following options are supported if the chardev interface is chosen:

       -c|--chardev <device path>
       --vtpm-proxy

XDG_CONFIG_HOME="/home/jlm/.config"
swtpm_setup --tpm2 --tpmstate ${XDG_CONFIG_HOME}/mytpm1 --create-ek-cert --create-platform-cert --lock-nvram
echo $XDG_CONFIG_HOME
/home/jlm/.config
export TPM2TOOLS_TCTI="swtpm:port=2321"
swtpm socket --tpmstate dir=<swtpm_path> --tpm2 --server type=tcp,port=2321 --ctrl type=tcp,port=2322 --flags not-need-init,startup-clear


export XDG_CONFIG_HOME="/home/jlm/.config"
sudo swtpm_setup --tpm2 --tpmstate ${XDG_CONFIG_HOME}/mytpm1 --create-ek-cert --create-platform-cert --lock-nvram
sudo swtpm chardev -c /dev/vtpm --vtpm-proxy --tpmstate dir=${XDG_CONFIG_HOME}/mytpm1 --tpm2 --ctrl type=tcp,port=2322

sudo swtpm chardev --vtpm-proxy --tpmstate dir=${XDG_CONFIG_HOME}/mytpm1 --tpm2 --ctrl type=unixio
/usr/bin/echo "capability sys_admin," > /etc/apparmor.d/local/usr.bin.swtpm
/usr/bin/echo "capability sys_admin," > /etc/apparmor.d/local/usr.bin.swtpm
aa-enforce /usr/bin/swtpm

modprobe tpm_vtpm_proxy
swtpm chardev --vtpm-proxy --tpmstate dir=... --tpm2 ...

mkdir -p /tmp/my_swtpm_dir
swtpm_setup --tpm2 --tpmstate ${XDG_CONFIG_HOME}/mytpm1 --create-ek-cert --create-platform-cert --lock-nvram

sudo apt update
sudo apt install swtpm swtpm-tools apparmor -y

---------------------------

To run the simulator:

Start:

export XDG_CONFIG_HOME="/home/jlm/.config"
echo $XDG_CONFIG_HOME

sudo modprobe tpm_vtpm_proxy

sudo swtpm_setup --tpm2 --tpmstate ${XDG_CONFIG_HOME}/mytpm1 --create-ek-cert --create-platform-cert --lock-nvram --print-capabilities

If you use the tcp utility
sudo swtpm socket --tpmstate dir=${XDG_CONFIG_HOME}/mytpm1 --tpm2 --server type=tcp,port=2321 --ctrl type=tcp,port=2322 --flags not-need-init,startup-clear &

If you use the vtpm2 device (/dev/tpm1)
sudo swtpm chardev --vtpm-proxy --tpmstate dir=${XDG_CONFIG_HOME}/mytpm1 --tpm2 --ctrl type=tcp,port=2322 --flags not-need-init,startup-clear &

sudo ./tpm2_util.exe --tpm_device="/dev/tpm1" --command=GetRandom --numbytes=32
sudo ./tpm2_util.exe --tpm_device="/dev/tpm1" --pcr_num=7 --command=EndorsementTest
sudo ./tpm2_util.exe --tpm_device="/dev/tpm1" --command=ContextTest
sudo ./tpm2_util.exe --tpm_device="/dev/tpm1" --pcr_num=7 --command=SealTest
sudo ./tpm2_util.exe --tpm_device="/dev/tpm1" --command=KeyTest
sudo ./tpm2_util.exe --tpm_device="/dev/tpm1" --command=NvTest
sudo ./tpm2_util.exe --tpm_device="/dev/tpm1" --pcr_num=7 --command=QuoteTest

To decode error messages:
  tpm2_rc_decode 0x921

----------------------------

