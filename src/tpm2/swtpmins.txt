swtpm_setup --tpm2 --tpmstate ${XDG_CONFIG_HOME}/mytpm1     --create-ek-cert --create-platform-cert --lock-nvram
echo $XDG_CONFIG_HOME
/home/jlm/.config
export TPM2TOOLS_TCTI="swtpm:port=2321"
swtpm socket --tpmstate dir=<swtpm_path> --tpm2 --server type=tcp,port=2321 --ctrl type=tcp,port=2322 --flags not-need-init,startup-clear

mkdir -p /tmp/my_swtpm_dir
swtpm_setup --tpm2 --tpmstate /tmp/my_swtpm_dir/ --create-ek-cert --create-platform-cert --lock-nvram
export TPM2TOOLS_TCTI="swtpm:path=/tmp/my_swtpm_dir/swtpm-sock"
tpm2_pcrread sha256
It can interact via a character device path (e.g., /dev/tpm0) 


PCR commands:
TPM2_PCR_Extend, TPM2_PCR_Event, TPM2_Read, TPM2_Reset, TPRM2_Allocate, TPM2_SetAuthorizationPolicy, TPM2_SetAuthorizationValue.

Seal
    1. Construct policy using tpm2_createpolicy, TPM2_policypcr
    2. TPM2_GetRandom to generate key
    3. TPM2_Create to specify policy and key

Unseal
    1. Start Session Auth
    2. TPM2_Load
    3. PolicyPCR
    4. TPM2_Unseal (with blob from Create)
    5. Close session: tpm2_flushcontext

Quote
    1. Policy
    2. Use TPM_GENERATED
    3. Specify qualified name
    4. Specify extra data
    5. FW
    6. Clock
    7. PCR numbers
    8. Digest of PCRs
    9. TPM2_Quote
    10. You have to reload these


in /usr/bin

tpm2_activatecredential
tpm2_certify
tpm2_certifycreation
tpm2_certifyX509certutil
tpm2_changeauth
tpm2_changeeps
tpm2_changepps
tpm2_checkquote
tpm2_clear
tpm2_clearcontrol
tpm2_clockrateadjust
tpm2_commit
tpm2_create
tpm2_createak
tpm2_createek
tpm2_createpolicy
tpm2_createprimary
tpm2_dictionarylockout
tpm2_duplicate
tpm2_ecdhkeygen
tpm2_ecdhzgen
tpm2_ecephemeral
tpm2_encodeobject
tpm2_encryptdecrypt
tpm2_eventlog
tpm2_evictcontrol
tpm2_flushcontext
tpm2_getcap
tpm2_getcommandauditdigest
tpm2_geteccparameters
tpm2_getekcertificate
tpm2_getpolicydigest
tpm2_getrandom --hex 32
tpm2_getsessionauditdigest
tpm2_gettestresult
tpm2_gettime
tpm2_hash
tpm2_hierarchycontrol
tpm2_hmac
tpm2_import
tpm2_incrementalselftest
tpm2_load
tpm2_loadexternal
tpm2_makecredential
tpm2_nvcertify
tpm2_nvdefine
tpm2_nvextend
tpm2_nvincrement
tpm2_nvread
tpm2_nvreadlock
tpm2_nvreadpublic
tpm2_nvsetbits
tpm2_nvundefine
tpm2_nvwrite
tpm2_nvwritelock
tpm2_pcrallocate
tpm2_pcrevent
tpm2_pcrextend
tpm2_pcrread
tpm2_pcrreset
tpm2_policyauthorize
tpm2_policyauthorizenv
tpm2_policyauthvalue
tpm2_policycommandcode
tpm2_policycountertimer
tpm2_policycphash
tpm2_policyduplicationselect
tpm2_policylocality
tpm2_policynamehash
tpm2_policynv
tpm2_policynvwritten
tpm2_policyor
tpm2_policypassword
tpm2_policypcr
tpm2_policyrestart
tpm2_policysecret
tpm2_policysigned
tpm2_policytemplate
tpm2_policyticket
tpm2_print
tpm2_quote
tpm2_rc_decode
tpm2_readclock
tpm2_readpublic
tpm2_rsadecrypt
tpm2_rsaencrypt
tpm2_selftest
tpm2_send
tpm2_sessionconfig
tpm2_setclock
tpm2_setcommandauditstatus
tpm2_setprimarypolicy
tpm2_shutdown
tpm2_sign
tpm2_startauthsession
tpm2_startup
tpm2_stirrandom
tpm2_testparms
tpm2_tr_encode
tpm2_unseal
tpm2_verifysignature
tpm2_zgen2phase

tpm2_getrandom --hex 32
tpm2_readclock
tpm2_pcrread sha256
tpm2_policypcr [ -L | --policy=<value>] [ -f | --pcr=<value>] [ -l | --pcr-list=<value>] [ -S | --session=<value>]
tpm2_createpolicy [ -L | --policy=<value>] [ -g | --policy-algorithm=<value>] [ -l | --pcr-list=<value>] [ -f | --pcr=<value>]
    [ --policy-pcr] [ --policy-session]
tpm2_create [ -P | --parent-auth=<value>] [ -p | --key-auth=<value>] [ -g | --hash-algorithm=<value>] [ -G | --key-algorithm=<value>]
    [ -a | --attributes=<value>] [ -i | --sealing-input=<value>] [ -L | --policy=<value>] [ -u | --public=<value>]
    [ -r | --private=<value>] [ -C | --parent-context=<value>] [ -c | --key-context=<value>] [ --creation-data=<value>]
    [ --template-data=<value>] [ -t | --creation-ticket=<value>] [ -d | --creation-hash=<value>] [ -q | --outside-info=<value>]
    [ -l | --pcr-list=<value>] [ --cphash=<value>] [ --rphash=<value>] [ -S | --session=<value>]
    [ -f | --format=<value>] [ -o | --output=<value>]
tpm2_startauthsession    [ --policy-session] [ --audit-session] [ --bind-context=<value>] [ --bind-auth=<value>]
    [ --tpmkey-context=<value>] [ --hmac-session] [ -g | --hash-algorithm=<value>] [ -G | --key-algorithm=<value>]
    [ -S | --session=<value>] [ -c | --key-context=<value>] [ -n | --name=<value>]
tpm2_unseal [ -p | --auth=<value>] [ -o | --output=<value>] [ -c | --object-context=<value>] [ --cphash=<value>]
    [ --rphash=<value>] [ -S | --session=<value>]
tmp2_quote [ -c | --key-context=<value>] [ -p | --auth=<value>] [ -l | --pcr-list=<value>] [ -q | --qualification=<value>]
    [ -s | --signature=<value>] [ -m | --message=<value>] [ -o | --pcr=<value>] [ -F | --pcrs_format=<value>]
    [ -f | --format=<value>] [ -g | --hash-algorithm=<value>] [ --cphash=<value>] [ --scheme=<value>]


tpm2_load [ -P | --auth=<value>] [ -u | --public=<value>] [ -r | --private=<value>] [ -n | --name=<value>]
    [ -c | --key-context=<value>] [ -C | --parent-context=<value>] [ --cphash=<value>]


Tpm2_StartAuthSession(LocalTpm& tpm, TPM_RH tpm_obj, TPM_RH bind_obj, TPM2B_NONCE& initial_nonce, TPM2B_ENCRYPTED_SECRET& salt, TPM_SE session_type, TPMT_SYM_DEF& symmetric, TPMI_ALG_HASH hash_alg, TPM_HANDLE* session_handle, TPM2B_NONCE* nonce_obj);
bool Tpm2_PolicyPcr(LocalTpm& tpm, TPM_HANDLE session_handle, TPM2B_DIGEST& expected_digest, TPML_PCR_SELECTION& pcr);



TPM2 Qualified Names are unique identifiers for TPM objects (keys, NV indices)
that include the hash of the parent object’s name in the hierarchy (e.g.,
Endorsement Hierarchy). This structure binds an object to its parent, ensuring
it belongs to a specific TPM, crucial for remote attestation and ensuring secure,
trusted key creation.

Definition: A qualified name is the name algorithm hash of the parent’s
qualified name concatenated with the object’s own name.

Purpose: It acts as proof that an object, such as an Attestation Key (AK),
was created under a specific parent object, typically the Endorsement Key (EK).

Hierarchy Binding: The qualified name chain extends from the object up to
the Primary Seed (e.g., Owner, Platform, or Endorsement Hierarchy),
allowing verification of the entire hierarchy.

Usage in Tools: tpm2_createak utilizes the -q option to record this,
verifying the key's ancestry. tpm2_readpublic is used to read this name.

Structure: Unlike a simple name, which is just the hash of the public
area, the qualified name includes the parent's information, providing
a secure, hierarchical, and verifiable identifier for keys. 


GetEndorsementKey.cc
  primary_flags.fixedTPM = 1;
  primary_flags.fixedParent = 1;
  primary_flags.sensitiveDataOrigin = 1;
  primary_flags.userWithAuth = 1;
  primary_flags.decrypt = 1;
  primary_flags.restricted = 1;
  InitSinglePcrSelection(7, hash_alg_id, &pcrSelect);
  if (Tpm2_CreatePrimary(tpm, TPM_RH_ENDORSEMENT, emptyAuth, pcrSelect,
                         TPM_ALG_RSA, hash_alg_id, primary_flags,
                         TPM_ALG_AES, 128, TPM_ALG_CFB, TPM_ALG_NULL,
                         2048, 0x010001, &ekHandle, &pub_out))
  Tpm2_ReadPublic(tpm, ekHandle, &pub_blob_size, pub_blob,
                      &pub_out, &pub_name, &qualified_pub_name)
  Tpm2_FlushContext(tpm, ekHandle);

  string authString("01020304");
  string parentAuth("01020304");
  string emptyAuth;

  TPML_PCR_SELECTION pcrSelect;
  TPMA_OBJECT root_flags;

  TPM2B_CREATION_DATA creation_out;
  TPM2B_DIGEST digest_out;
  TPMT_TK_CREATION creation_ticket;

  TPM_HANDLE root_handle = 0;
  TPM2B_PUBLIC root_pub_out;

  TPM_HANDLE seal_load_handle = 0;
  TPMA_OBJECT seal_create_flags;
  TPM2B_NAME seal_name;
  int seal_size_public = MAX_SIZE_PARAMS;
  byte seal_out_public[MAX_SIZE_PARAMS];
  int seal_size_private = MAX_SIZE_PARAMS;
  byte seal_out_private[MAX_SIZE_PARAMS];

  TPMA_OBJECT quote_create_flags;
  TPM2B_NAME quote_name;
  TPM_HANDLE quote_load_handle = 0;
  int quote_size_public = MAX_SIZE_PARAMS;
  byte quote_out_public[MAX_SIZE_PARAMS];
  int quote_size_private = MAX_SIZE_PARAMS;
  byte quote_out_private[MAX_SIZE_PARAMS];

  TPM_HANDLE nv_handle = 0;
  byte context_save_area[MAX_SIZE_PARAMS];
  uint16_t context_data_size = MAX_SIZE_PARAMS;
  TPM_HANDLE sealed_load_handle = 0;
  TPM_ALG_ID hash_alg_id;
  InitSinglePcrSelection(7, hash_alg_id, &pcrSelect);
  *(uint32_t*)(&root_flags) = 0;
  root_flags.fixedTPM = 1;
  root_flags.fixedParent = 1;
  root_flags.sensitiveDataOrigin = 1;
  root_flags.userWithAuth = 1;
  root_flags.decrypt = 1;
  root_flags.restricted = 1;
  if (Tpm2_CreatePrimary(tpm, TPM_RH_OWNER, authString, pcrSelect,
                         TPM_ALG_RSA, hash_alg_id, root_flags,
                         TPM_ALG_AES, 128, TPM_ALG_CFB, TPM_ALG_NULL,
                         2048, 0x010001, &root_handle, &root_pub_out)) 
 *(uint32_t*)(&seal_create_flags) = 0;
  seal_create_flags.fixedTPM = 1;
  seal_create_flags.fixedParent = 1;
  seal_create_flags.sensitiveDataOrigin = 1;
  seal_create_flags.userWithAuth = 1;
  seal_create_flags.sign = 1;

  if (Tpm2_CreateKey(tpm, root_handle, parentAuth, authString, pcrSelect,
                     TPM_ALG_RSA, hash_alg_id, seal_create_flags, TPM_ALG_NULL,
                     (TPMI_AES_KEY_BITS)0, TPM_ALG_ECB, TPM_ALG_RSASSA,
                     2048, 0x010001, &seal_size_public, seal_out_public,
                     &seal_size_private, seal_out_private,
                     &creation_out, &digest_out, &creation_ticket)) {
  if (Tpm2_Load(tpm, root_handle, parentAuth, seal_size_public,
                seal_out_public, seal_size_private, seal_out_private,
                &seal_load_handle, &seal_name)) {

  *(uint32_t*)(&quote_create_flags) = 0;
  quote_create_flags.fixedTPM = 1;
  quote_create_flags.fixedParent = 1;
  quote_create_flags.sensitiveDataOrigin = 1;
  quote_create_flags.userWithAuth = 1;
  quote_create_flags.sign = 1;
  quote_create_flags.restricted = 1;
  if (Tpm2_CreateKey(tpm, root_handle, parentAuth, authString, pcrSelect,
                     TPM_ALG_RSA, hash_alg_id, quote_create_flags, TPM_ALG_NULL,
                     (TPMI_AES_KEY_BITS)0, TPM_ALG_ECB, TPM_ALG_RSASSA,
                     1024, 0x010001,
                     &quote_size_public, quote_out_public,
                     &quote_size_private, quote_out_private,
                     &creation_out, &digest_out, &creation_ticket)) {
  if (Tpm2_Load(tpm, root_handle, parentAuth, quote_size_public,
                quote_out_public, quote_size_private, quote_out_private,
                &quote_load_handle, &quote_name)) {
  nv_handle = GetNvHandle(FLAGS_slot_primary);
  context_data_size = MAX_SIZE_PARAMS;
  if (!Tpm2_SaveContext(tpm, root_handle, &context_data_size,
                        context_save_area)) {
  Tpm2_UndefineSpace(tpm, TPM_RH_OWNER, nv_handle))
  if (!Tpm2_WriteNv(tpm, nv_handle, authString,
                    (uint16_t)context_data_size, context_save_area)){
  if (!Tpm2_SaveContext(tpm, seal_load_handle, &context_data_size,
                        context_save_area)) {

  if (!Tpm2_WriteNv(tpm, nv_handle, authString,
                    (uint16_t)context_data_size, context_save_area)){
  // Save quote context
  nv_handle = GetNvHandle(FLAGS_slot_quote);
  context_data_size = MAX_SIZE_PARAMS;
  if (!Tpm2_SaveContext(tpm, quote_load_handle, &context_data_size,
                        context_save_area)) {
  if (root_handle != 0) {
    Tpm2_FlushContext(tpm, root_handle);
  }
  if (seal_load_handle != 0) {
    Tpm2_FlushContext(tpm, seal_load_handle);
  }
  if (quote_load_handle != 0) {
    Tpm2_FlushContext(tpm, quote_load_handle);
  }
  if (sealed_load_handle != 0) {
    Tpm2_FlushContext(tpm, sealed_load_handle);


